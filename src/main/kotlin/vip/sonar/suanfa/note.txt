## 1. 链表

1. 2019-02-26
    a.单链表与循环链表 - 未使用哨兵节点
        (SingleLink.kt 、CircleLink.kt)

2. 2019-02-27
    a.单链表与循环链表 - 使用哨兵节点
     (SingleLink2.kt 、CircleLink2.kt)
3. 2019-02-28
    a. 双向循环列表
      DoubleLink.
4. 2019-03-01
    a. 单链表判断回文
       Test_huiwen.kt
    b. 单链表反转
        Test_revert_single.kt
    c. 链表是否有环
        Test_is_circle.kt
    d. 2个有序链表合并
        Test_two_link_merge.kt
    e. 删除链表倒数第 n 个结点
        Test_del_backward_node.kt
5. 2019-03-02
    a. 删除链表倒数第 n 个结点
        参考：https://github.com/wangzheng0822/algo/blob/master/java/07_linkedlist/LinkedListAlgo.java
    b. 求链表的中间结点
       Test_get_middle.kt

## 2. 栈

1. 2019-03-03
    a.链表实现栈练习
        Stack_ByLink.kt
2. 2019-03-04
    a.队列
        queue/QueueTest.kt
3. 2019-03-05
   循环队列
        queue/CircleTest.kt
4. 2019-03-08
    sort/Guibing.kt
5. 2019-03-10
    sort/QuickSort.kt
6. 2019-03-13
    基数排序卡住了2天；
    a.桶排序：
        sort/BucketSort.kt
7. 2019-03-14
    a.计数排序
        sort/CountingSort.kt
    b.基数排序
        sort/RadixSort.kt
8. 2019-03-15
    a.基数排序
      sort/RadixSort.kt
9. 2019-03-17
    二分查找，看似简单其实越难掌握，灵活应用就更加困难；
        binarysearch/BinarySearch.kt
    计算平方根
        binarysearch/Greedy.kt

10. 2019-03-18
    二分查找变形问题
         binarysearch/Binary.kt

11. 2019-03-19
    跳表
        skiplist/
12. 2019-03-20
    跳表难 TODO 需要时间理解
13. 2019-03-21
    了解散列表的概念；
14. 2019-03-24
    装载因子：散列表的装载因子 = 填入表中的元素个数 / 散列表的长度
    了解散列函数的设计方法：
        将单词中每个字母的ASCll 码值“进位”相加,然后再跟散列表的大小求余、取模，作为散列值。
15. 2019-03-25 / 26
    Java HashMap 了解；
    hashCode 函数分析：
16. 2019-03-27
    Lrucache原理了解
17. 2019-03-28
    hash算法的了解；
18. 2019-03-30
    hash算法的了解；
19. 2019-04-01
    二叉树了解
20. 2019-04-03
    二叉树的3种遍历
21. 2019-04-06
    了解二叉查找树
22. 2019-04-08
    了解二叉查找树
22. 2019-04-09
    二叉查找树，添加，查找
23. 2019-04-10
    二叉查找树删除操作，先查找，再删除
24. 2019-04-11
    重写二叉查找树删除操作，先查找，再删除
25. 2019-04-16
    可恶的996；影响我进度；了解红黑树；
26. 2019-04-17
    https://segmentfault.com/a/1190000012728513?utm_source=tag-newest
    a).节点是红色或黑色。
    b).根是黑色。
    c).所有叶子都是黑色（叶子是NIL节点）。
    d).每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）
    e).从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点（简称黑高）。
27. 2019-04-18
    左右旋了解；
28. 2019-04-19
    加班
29. 2019-04-20
    红黑树插入过程了解
    rb 包下；
    参考博客，代码实现部分（左右旋，插入）
30. 2019-04-21
    找房子，可以准备搬家了；走了一天，晚上确定好的；
    参考博客，代码实现部分（左右旋，插入），代码还有些问题；
31. 2019-04-22
    修正插入问题
32. 2019-04-23
    默写红黑树插入，涉及左右旋，变色，变换；
33. 2019-04-25
    了解删除过程
34. 2019-04-28
    前几天搬家，收拾整理，日子过得很快；
35. 2019-05-1
    懒了几天，今天将二叉查找树，前驱与后继节点补齐;
    binarytree/SearchBinaryTree.kt
36. 2019-05-04
    直接参考原码
37. 2019-05-05
    直接参考博客源码
38. 2019-05-08
    very hard
39. 2019-05-11
    参考博客输出树结构
40. 2019-05-13
    删除的节点只有一个孩子实现
41. 2019-05-17
    继续删除，无子孩子的情况
42. 2019-05-21
    基本完成删除操作；
43. 2019-05-22
    删除代码修正
45. 2020-01-31
    跳表
    skiplist/two
46. 2020-02-01
    散列表 hash 的了解 TODO 需要深究
    /hash/Test1.kt
47. 2020-02-02
    LRU TODO 散列表与链表结合使用没看懂
    TODO 哈希算法的应用
    https://time.geekbang.org/column/article/64858
    散列表的数据本来就是无序的，那么 LinkedHashMap 是如何做到做到有序的呢，这是我的问题
    --》虽然散列表的数据是无序的，在数据A进入散列表时（无序存在）,将 A copy 到链表（或数组）中（散列表中不存原始数据了），这样A在链表中就是有序的了，
        遍历此链表，就可以输出顺序添加到散列表中的数据。
    -----
    看好些人询问LRU中设计的到pre，next和hnext的具体含义，将自己的理解说下，pre和next组成双向链表，这个链表是按照缓存的时间由大到小，
    组成的一个缓存队列；
    对于hnext作用是，在最新时间插入缓存数据时，通过哈希函数得出的冲突，用其连接。
    总结：在双向链表中，时间是从大到小；在hnext组成的拉链中，时间从左到右依次变小。
    核心：数据结构的设计，一定是建立应用场景之上，根据最新时间加入缓存。
    这是自己的见解，若是有错误，希望争哥不吝赐教，thanks

47. 2020-02-03
    a. 二叉树继承 /binary/two
       生成二叉树、前、中、后、层序遍历
48. 2020-02-05
    二叉查找树，重写 添加、查询、删除操作
49. 2020-02-06
    a.hashTable的详细说明
        https://www.hackerearth.com/zh/practice/data-structures/hash-tables/basics-of-hash-tables/tutorial/
        hash/test2
    b.二叉查找树 获取最大、最小节点
49. 2020-02-07
    二叉查找树，获取前驱与后继，重复节点的增、查、删
    binarytree/two/Test2_Search2_repeat
50. 2020-02-08
    a.修复二叉查找树，删除重复节点问题
    b.求二叉树的高度
