1. 同步容器的问题
    思路：
        锁不一样
    解决：
        客户端有一些新操作时（复合操作），使用同一锁
    示例：
        Test1_vector_problem

2.迭代器与concurrent_modify_exception
    思路：
        ArrayList非线程安全
    解决：
        加锁防止 concurrent_modify_exception
    示例：
        Test2_concurrent_modify_exception

3. 隐藏迭代器加锁，有些容易的系统方法，比如：toString，会隐士的调用迭代器，这种情况尤佳要注意；
   容器的hashCode、equals等会间接的执行迭代操作；
    思路：
        注意调用的方法中，是否包含了对迭代器的访问
    解决：
        加锁，或同步容器
    示例：
        Test3_hidden_iterator

###### **** Java 提供的并发工具 **** #######
4. BlockingQueued的使用
    a.Test4_blockingQueue_1
    b.Test5_blockingQueue_2  // 文件搜索

5.CountDownLatch 闭锁的使用
    a.Test6_CountDownLatch_1
    b.Test7_CountDownLatch_2  // 模拟游戏匹配过程

6. Future模式的使用
    a.Test8_Future_1    // 获取Callable结果
    b.Test9_Future_2    // FutureTask的例子
    c.Test10_Future_2   // 搜索文件例子

7. Thread.join    // 把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程
   a.Test0_join  // 把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程

